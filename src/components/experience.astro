<canvas class="webgl"></canvas>

<style>
  .webgl {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 1px solid red;
    outline: none;
  }
</style>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
  import * as dat from "lil-gui";
  import vertexShader from "../components/three/shaders/vertex.glsl";
  import fragmentShader from "../components/three/shaders/fragment.glsl";
  import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
  import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry.js";

  // ATTRIBUTES are associated with each VERTEX
  // UNIFORMS are the same throughout each VERTEX
  //
  // ════════════════════════════════════
  //             Base
  // ════════════════════════════════════
  //
  // Debug
  const gui = new dat.GUI();

  // Canvas
  const canvas = document.querySelector("canvas.webgl");

  // Scene
  const scene = new THREE.Scene();

  //
  // ════════════════════════════════════
  //             Textures
  // ════════════════════════════════════
  //
  const textureLoader = new THREE.TextureLoader();
  // const flagTexture = textureLoader.load("/images/Sling-dark.png");

  // •───────•°•❀•°•───────•
  //           mesh
  // •───────•°•❀•°•───────•

  // Geometry
  const geometry = new THREE.PlaneGeometry(1, 1, 64, 64);

  // create count attribute (number of vertices)
  const count = geometry.attributes.position.count;
  // // set the length of the array to `count`
  const randoms = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    randoms[i] = Math.random();
  }
  // value after `randoms` is how many values to take from the array for one vertex
  // if we're changing the position, we need 3 (x,y,z)
  geometry.setAttribute("aRandom", new THREE.BufferAttribute(randoms, 1));

  // •───────•°•❀•°•───────•
  //       GLSL Material
  // •───────•°•❀•°•───────•
  const material = new THREE.ShaderMaterial({
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true,
    // wireframe: true,
    uniforms: {
      // sin frequency
      uFrequency: { value: new THREE.Vector2(2.5, 1.5) }, // was 10, 5
      // give the shaders a time value, see tick()
      uTime: { value: 0 },
      // add texture
      // uTexture: { value: flagTexture },
      // add color
      uColor: { value: new THREE.Color(0xfff) },
    },
    side: THREE.DoubleSide,
  });

  gui
    .add(material.uniforms.uFrequency.value, "x")
    .min(0)
    .max(20)
    .step(0.01)
    .name("freqX");
  gui
    .add(material.uniforms.uFrequency.value, "y")
    .min(0)
    .max(20)
    .step(0.01)
    .name("freqY");

  // Mesh
  // const mesh = new THREE.Mesh(textGeometry, material);
  // mesh.scale.y = 2 / 3;
  // scene.add(mesh);

  const textLoader = new FontLoader();
  let textGeometry; // Declare textGeometry in the outer scope

  textLoader.load("/fonts/arial-narrow.json", function (font) {
    textGeometry = new TextGeometry("Sling", {
      font: font,
      size: 1.4, // Adjust the size as needed
      height: 0, // Adjust the height as needed
      curveSegments: 24,
    });

    textGeometry.center();
    // Create a mesh using the TextGeometry and ShaderMaterial
    const textMesh = new THREE.Mesh(textGeometry, material);

    // You can position and add the textMesh to the scene
    textMesh.position.set(0, 0, 0); // Adjust the position as needed
    scene.add(textMesh);
  });

  //
  // ════════════════════════════════════
  //             Sizes
  // ════════════════════════════════════
  //
  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
  };

  window.addEventListener("resize", () => {
    // Update sizes
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    // Update camera
    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    // Update renderer
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });

  //
  // ════════════════════════════════════
  //             Camera
  // ════════════════════════════════════
  //
  // Base camera
  const camera = new THREE.PerspectiveCamera(
    75,
    sizes.width / sizes.height,
    0.1,
    100
  );
  camera.position.set(0, 0, 2);
  scene.add(camera);

  // Controls
  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  // controls.autoRotate = true;
  controls.enableZoom = false;

  //
  // ════════════════════════════════════
  //             Renderer
  // ════════════════════════════════════
  //
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: true,
  });

  renderer.setSize(sizes.width, sizes.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // const backgroundColor = new THREE.Color(0xffffff);
  // renderer.setClearColor(backgroundColor, 1);

  //
  // ════════════════════════════════════
  //             Animate
  // ════════════════════════════════════
  //

  // let mouseX = 0;
  // let mouseY = 0;

  // canvas.addEventListener("mousemove", (event) => {
  //   // Calculate the mouse position within the canvas
  //   const rect = canvas.getBoundingClientRect();
  //   mouseX = (event.clientX - rect.left) / canvas.width;
  //   mouseY = 1 - (event.clientY - rect.top) / canvas.height; // Invert Y-axis
  // });

  const clock = new THREE.Clock();

  const tick = () => {
    const elapsedTime = clock.getElapsedTime();

    // update material
    material.uniforms.uTime.value = elapsedTime;

    // Update material uniforms based on mouse position
    // material.uniforms.uFrequency.value.x = mouseX * 20; // Adjust the factor as needed
    // material.uniforms.uFrequency.value.y = mouseY * 20; // Adjust the factor as needed

    // Update controls
    controls.update();

    // Render
    renderer.render(scene, camera);

    // Call tick again on the next frame
    window.requestAnimationFrame(tick);
  };

  tick();
</script>
